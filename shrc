#!/bin/sh

# Utilities

run_command_with_file() (
  set -e

  command=$1
  shift

  if [ $# -eq 0 ]; then
    file=$( (git ls-files -co --exclude-standard 2>/dev/null || fd -t f .) | fzf)

    [ -n "$file" ]
    "$command" "$file"
  else
    "$command" "$@"
  fi
)

# cd

alias ch='cd "$(dirs -lp | sort -u | fzf)"'
alias cr='cd "$(fd -at d . $(git rev-parse --show-toplevel) | fzf)"'
alias cs='cd "$(ghq list --full-path | fzf)"'
alias ct='cd "$(git rev-parse --show-toplevel)"'

command=..
directory=..

for _ in $(seq 10); do
  command=$command.
  directory=$directory/..

  alias $command=$directory
done

c() {
  local directory=$(fd -t d . | fzf)

  [ -n "$directory" ] &&
    cd "$directory"
}

# tmux

alias t=tmux
alias ta='tmux a'
alias tl='tmux ls'

# Zellij

alias z=zellij
alias za='zellij a'
alias zl='zellij ls'

# git

alias gap='git add --patch'
alias gb='git branch'
alias gba='git branch -a'
alias gbd='git branch -d'
alias gc="git commit"
alias gca="git commit --amend"
alias gcr='git commit -m Refactor'
alias gcw='git commit -m WIP'
alias gcp='git cherry-pick'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdh='git diff HEAD^ HEAD'
alias gl='git log'
alias glf='git log -p --name-only'
alias glo='git log --graph --oneline'
alias glp='git log -p'
alias gm='git merge'
alias gpl='git pull'
alias gpp='git pull && git push'
alias gppa='git pull --all && git push'
alias gpr='gh pr checkout $(gh pr list --limit 1024 | fzf | cut -f 1)'
alias gps='git push'
alias gpsu='git push -u origin $(git symbolic-ref --short HEAD)'
alias gr='git restore'
alias gri='git rebase -i'
alias grm='git rebase $(git_default_branch)'
alias gs='git status'
alias gsm='git submodule'
alias gsma='git submodule add'
alias gsmu='git submodule update --init --recursive'
alias gsw='git switch'
alias gswc='git switch -C'
alias gswm='git switch $(git_default_branch)'
alias gw='git worktree'
alias gwc='cd "$(git worktree list | fzf | cut -f 1 -d " ")"'
alias gwl='git worktree list'
alias gwr='git worktree remove "$(git worktree list | fzf | cut -f 1 -d " ")"'
alias gz='git stash'
alias gza='git stash apply'
alias gzd='git stash drop'
alias gzl='git stash list'
alias gzp='git stash pop'
alias gzs='git stash show -p'

git_default_branch() (
  set -e
  git remote set-head origin --auto >/dev/null
  git symbolic-ref --short refs/remotes/origin/HEAD | sed "s%.*/%%"
)

ga() (
  set -e

  if [ $# -eq 0 ]; then
    git add --all
  else
    git add "$@"
  fi

  git status
)

gls() (
  set -e

  commit=$(
    git log --oneline "$@" |
      fzf --exit-0 --no-sort --preview 'git show --stat $(echo {} | grep -o "[a-f0-9]\+" | head -1)' |
      grep -o '[a-f0-9]\+' |
      head -1
  )

  [ -n "$commit" ]
  git show --show-signature $commit
)

grh() (
  set -e
  message=$(git log --format=%B -n 1 HEAD^)
  git reset --soft HEAD^^
  git commit -m "$message"
)

gwa() {
  [ $# -eq 0 ] || return 1

  local directory=~/worktree/$(openssl rand -hex 8)

  git worktree add "$directory" $(git branch --format '%(refname:short)' | fzf)
  cd "$directory"
  git submodule update --init --recursive
}

# Editor

alias e='run_command_with_file nvim'

eg() (
  set -e

  line=$(rg -n . | fzf)

  field() (
    echo "$line" | cut -f $1 -d :
  )

  file=$(field 1)

  [ -n "$file" ]
  nvim +"execute $(field 2) | normal zz" "$file"
)

er() (
  set -e

  directory=$(git rev-parse --show-toplevel)
  file=$(git ls-files --full-name $directory | fzf)

  [ -n "$file" ]
  nvim "$directory/$file"
)

# ls

if which eza >/dev/null; then
  alias ls='eza --no-quotes'
fi

alias d=ls
alias d1='ls -1'
alias da='ls -a'
alias dl='ls -l'
alias dla='ls -la'
alias dm='ls ~'
alias dma='ls -a ~'
alias ds='ghq list --full-path'
alias dt='ls --tree --level 2'

# Others

alias f='run_command_with_file bat'
alias bacon='bacon --headless'
alias btm='btm -bn'
alias less='less -R'
alias s="$(which rg >/dev/null 2>&1 && echo 'rg --column --line-number' || echo 'grep -Hnr --color')"
